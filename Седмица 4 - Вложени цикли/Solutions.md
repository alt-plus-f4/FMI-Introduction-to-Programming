**Задача 1**
```cpp
    int n;
    std::cin >> n;

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= i; j++)
        {
            std::cout << j << ' ';
        }

        std::cout << '\n'
    }
```

**Задача 2**

В решението на тази задача сме групирали условията за различните страни на квадрата, за да стане по-ясно какво се случва. Както споменахме в практикума, ```i``` отговаря на индекса на реда, а ```j``` на индекса на колоната. Следователно програмата ни проверява дали сме на първия ред (нулевия, защото ```i``` започва от ```0```) или последния (```n - 1```), за да начертае хоризонталните страни и дали сме на първата колона (нулевата, защото ```j``` започва от ```0```) или последната (```n - 1```), за да начертае вертикалните страни.

```cpp
    int n;
    std::cin >> n;

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            bool isHorizontalLine = i == 0 || i == n - 1; 
            bool isVerticalLine = j == 0 || j == n - 1;

            if (isHorizontalLine || isVerticalLine)
            {
                std::cout << '*';
            }
            else
            {
                std::cout << ' ';
            }
        }

        std::cout << '\n';
    }
```

**Задача 3**

В кои случаи рисуваме ```+``` на матрицата? В тези, при които индексът на реда е по-МАЛЪК от индекса на колоната (```i < j```)! А в кои чертаем ```-```? В тези, при които индексът на реда е по-ГОЛЯМ от индекса на колоната (```i > j```)! Единственият останал случай е ```i == j```. Именно това е условието за рисуване на главния диагонал на матрицата (```o```)! :) 

```cpp
    int n;
    std::cin >> n;

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i > j)
            {
                std::cout << '-';
            } 
            else if (i < j)
            {
                std::cout << '+';
            }
            else // с други думи, когато i == j
            {
                std::cout << 'o';
            }
        }

        std::cout << '\n';
    }
```

**Задача 4**

Тук инициализираме броячите на циклите с ```1```, за да не пресмятаме и принтираме резултата на ```0 x 0```.

```cpp
    int n;
    std::cin >> n;

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            std::cout << i * j << ' ';
        }

        std::cout << '\n';
    }
```

**Задача 5**

Нека да разбием тази задачка на две части. Първо искаме да принтираме клоните на елхата, а след това стъблото.
Започвайки с клоните на елхата, искаме да принтираме ```n``` реда за клоните (първия цикъл), всеки от които се състои от ```treeWidth / 2 - i``` брой разстояния (първия вложен цикъл) поставени преди ```currBranchWidth``` брой символа ```*``` (втория вложен цикъл). С други думи, разстоянията прогресивно намаляват с всеки нов ред, а звездичките се увеличават. 

Пример: 

При ```n = 5``` (Ще имаме ```5``` реда за клоните):

**I ред**: ```4``` разстояния ```1``` звезда

**II ред**: ```3``` разстояния ```2``` звезди

**III ред**: ```2``` разстояния ```3``` звезди

**IV ред**: ```1``` разстояние ```4``` звезди

---

Втората и последна част от задачката е да нарисуваме стъблото. За нея искаме отново да принтираме определен брой разстояния преди символа за стъблото ```|```. Тук обаче броя на символите на всеки ред е константен. Т.е.
имаме по условие, че височината на стъблото е ```n - 1``` (втория от двата външни цикъла). За да центрираме стъблото искаме всяко символче ```|``` да е на същото разстояние като най-високата/първата ```*```. Следователно въртим още един цикъл (вложения), който итерира от ```0``` до ```treeWidth / 2```. След вложения цикъл винаги принтираме по един ```|``` (и ```\n``` за новия ред).

```cpp
    int n;
    std::cin >> n;

    int treeWidth = n * 2 - 1;

    // Клоните на елхата
    for (int i = 0; i < n; i++)
    {
    	// разстоянието преди символите за клоните
    	for (int j = treeWidth / 2 - i; j > 0; j--)
    	{
    		std::cout << ' ';
    	}

    	int currBranchWidth = 2 * i + 1;

    	for (int j = 0; j < currBranchWidth; j++)
    	{
    		std::cout << '*';
    	}

    	std::cout << '\n';
    }

    // стъблото на елхата
    for (int i = 0; i < n - 1; i++)
    {
    	// разстоянието преди символите за стъблото
    	for (int j = 0; j < treeWidth / 2; j++)
    	{
    		std::cout << ' ';
    	}

    	std::cout << "|\n";
    }
```

**Задача 6**

Двете проверки във вложения цикъл са нужни, за да коригираме форматирането за едноцифрените часове и минути. С други думи да имаме ```09:09``` вместо ```9:9``` например.

```cpp
    for (int i = 0; i < 24; i++)
    {
        for (int j = 0; j < 60; j++)
        {
            if (i < 10)
            {
                std::cout << '0';
            }
            
            std::cout << i << ':';

            if (j < 10)
            {
                std::cout << '0';
            }

            std::cout << j << '\n';
        }
    }
```

**Задача 7**

**Забележка**: Ако на тази задача въведем ```n``` по-голямо от 9 ще имаме проблеми с подравняването на точката, но не обръщаме внимание на това. Ще се фокусираме само върху едноцифрените стойности.

Тук отново си имаме работа с индекси. Искаме докато рисуваме координатната система да нарисуваме и точката. Със знанията ни до момента не можем да нарисуваме точката след като сме нарисували координатанта система. Ще видим как като вземем масиви. :)

Първо валидираме входните данни. Подобно на задачата с квадрата, когато ```j == 0``` изписваме координатите на ординатата. Изписваме ги чрез формулата ```n - i```. Когато сме на ред ```0```, при ```n = 10``` например, ```10 - 0 = 10```. Така изписваме числото ```10```. С увеличаване индекса на реда (```n - 1, n - 2,...```) получаваме и останалите числа до ```0```. Друг случай е когато ```i == n```. Това значи, че сме на последния ред или с други думи на абсцисата. За да изпишем числата просто принтираме ```j```, защото се инициализира на ```0``` и се увеличава до ```n```. При всеки друг случай искаме да принтираме интервал.

Остава ни случая, когато ```i``` и ```j``` са стойностите на ```y``` и ```x```. Проверяваме го преди останалите с отделен ```if```, защото в противен случай (```if-else if``` конструкция) бихме пропуснали число на ординатата. Проверката за ```y``` е ```i == n - y```, за да съобразим разстоянието от осите.
Разбира се както в някои от горните задачи, принтираме празен ред след приключването на вложения цикъл.

```cpp
    int n, x, y;
    std::cin >> n >> x >> y;

    if (n < 0 || y < 0 || x < 0)
    {
    	std::cout << "Invalid input! X, Y and N cannot be   negative!";
    
    	return 0;
    }

    if (x > n || y > n)
    {
    	std::cout << "Invalid input! X and Y must be smaller than or equal to N";

    	return 0;
    }

    for (int i = 0; i <= n; i++)
    {
    	for (int j = 0; j <= n; j++)
    	{
    		if (j == x && i == n - y)
    		{
    			std::cout << '*';
    		}

    		if (j == 0)
    		{
    			std::cout << n - i;
    		}
    		else if (i == n)
    		{
    			std::cout << j;
    		}
    		else
    		{
    			std::cout << ' ';
    		}
    	}

    	std::cout << '\n';
    }
```
**Задача 1**  
Стандартно създаване на масив, със заделен фиксиран брой (32) целочислени стойности (`int`), но използваме само част от тях (`n` от тях, като `n` се въвежда от потребителя)  
После имаме променяне на стойността на всички членове в масива. След това имаме и стандратно принтиране.  
Общата идея е, че въртим цикъл през всеки един елемент на масива и го обработваме поотделно.  
```cpp
int square(int num)
{
    return num * num;
}

int main() {
    int n;
    std::cin >> n;
    int arr[32];

    //read array with lenght n
    for (int i = 0; i < n; i++)
    {
        std::cin >> arr[i];
    }

    for (int i = 0; i < n; i++)
    {
        arr[i] = square(arr[i]);
    }

    //print array
    for (int i = 0; i < n; i++)
    {
        std::cout << arr[i] << ' ';
    }
}
```  

**Задача 2**  
С тази задача искаме да ви покажем един готин "алгоритъм", когато трябва да работите с брой цифри в число или брой символи в низ. Доближава се до сортиращия алгоритъм известен като *Counting Sort*. Основната идея е да си пазим масив (от `int`), в който да пазим информация **колко пъти се среща дадено число/символ**. **Индексът** на всяка клетка в масива отговаря на **дадено число/символ**, а **стойността**, записана в тази клетка, отговаря на **колко пъти** това число/символ се е срещнало.  
Два доста чести примера са:
- масив с 10 елементи, който пази информация колко често се среща всяка цифра в някакво число.  
- масив с 26 елементи, който пази информация колко често се среща всяка латинска буква в даден низ.  

Разбира се, този метод може да се ползва по много различни начини. Тук сме използвали първия пример, за да видим кои числа се срещат точно по 1 път.
```cpp
int main() {
    long long number;
    std::cin >> number;

    //this will keep count of how many of each digit are in the number
    int occurCount[10] = {};

    //getting the count
    while (number != 0)
    {
        int lastDigit = number % 10;
        occurCount[lastDigit]++;
        number /= 10;
    }

    int sum = 0;

    //summing only if the digit occured only once
    for (int i = 0; i < 10; i++)
    {
        if (occurCount[i] == 1)
        {
            sum += i;   //notice how we add the index, which corresponds to the digit.
        }
    }
    std::cout << sum;
}
```
Естествено има и други начини за решаване на задачата, но този е по-бързичък и лесен за писане. Пък и искаме да ви покажем този трик, за да може да го ползвате когато е удобен.   

**Задача 3**  
Тук е интересен начинът, по който обединяваме масивите в един. Правим си нов индекс, който увеличаваме всеки път като добавим елемент в новия масив, а `i` от `for-loop`а ползваме за старите масиви. Съответно, при добавяне трябва да направим проверка дали не сме стигнали до края на някой от първите три масива.  
Ако искаме да избегнем ненужно циклене (в момента последния цикъл винаги ще върти до 30), може да намерим най-големия размер от трите масива и да циклим докато стигнем него.  
```cpp
int main() {
    int n, m, k;

    //read first
    std::cin >> n;
    int arr1[10];
    for (int = 0; i < n; i++)
    {
        std::cin >> arr1[i];
    }

    //read second
    std::cin >> m;
    int arr2[10];
    for (int = 0; i < m; i++)
    {
        std::cin >> arr2[i];
    }

    //read third
    std::cin >> k;
    int arr3[10];
    for (int = 0; i < k; i++)
    {
        std::cin >> arr3[i];
    }

    //create new
    int resArr[30];
    int index = 0;
    for (int i = 0; i < 30; i++)
    {
        if (i < n)
            resArr[index++] = arr1[i];
        if (i < m)
            resArr[index++] = arr2[i];
        if (i < k)
            resArr[index++] = arr3[i];
    }
    //the value of index is now actually the length of the new array!
    for (int i = 0; i < index; i++)
    {
        std::cout << resArr[i] << ' ';
    }
}
```

**Задача 4**  
Тук използваме функцията countOccurrences като подаваме съответния елемент на двата масива и проверяваме дали броя на срещанията е равен и в двата. Ако не, излизаме от цикъла и принтираме "false".

```cpp
int countOccurrences(int element, int numbers[], int size)
{
	int occCount = 0;

	for (int i = 0; i < size; i++)
	{
		if (numbers[i] == element)
		{
			occCount++;
		}
	}

	return occCount;
}

int main()
{
	int n;
	std::cin >> n;

	int firstArr[32];
	int secondArr[32];

	for (int i = 0; i < n; i++)
	{
		std::cin >> firstArr[i];
	}
	
	for (int i = 0; i < n; i++)
	{
		std::cin >> secondArr[i];
	}

	bool isPermutation = true;

	for (int i = 0; i < n; i++)
	{
		int firstArrOcc = countOccurrences(firstArr[i], firstArr, n);
		int secondArrOcc = countOccurrences(secondArr[i], secondArr, n);

		if (firstArrOcc != secondArrOcc)
		{
			isPermutation = false;
			break;
		}
	}

	std::cout << std::boolalpha << isPermutation;
}
```

**Задача 5**  
Чил задачка. За всяко число в масива проверяваме всички след него и ако се окаже, че има такова което е по-малко от него, добавяме +1 на броя инверсии.   
```cpp
int main() {
    int n;
    std::cin >> n;
    int arr[32];

    for (int i = 0; i < n; i++)
    {
        std::cin >> arr[i];
    }

    int numOfInv = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = i+1; j < n; j++)
        {
            if (arr[i] > arr[j])
                numOfInv++;
        }
    }
    std::cout << numOfInv;
}
```

**Задача 6**  
Както вече трябва да сте разбрали, низът (`string`, или по точно `C-style string`) в С++ е просто масив от символи (`char`), който завършва със специален символ - `'\0'`.  
Много важно е да отбележим, че кодът:  
```cpp
char string[10];
int n;
std::cin >> n;
for (int i = 0; i < n; i++)
{
    std::cin >> string[i];
}
string[n] = '\0';
```
е почти еквивалентен на кода:  
```cpp
char string[10];
std::cin >> string;
```
С разликата, че тук конзолата ще продължава да чете символи за да ги запише в масива, докато срещне първия *whitespace* (интервал, таб, нов ред). За това трябва да внимаваме да не превишим оригинално зададения размер без да искаме. Също малко неудобство е, че не знаем размера на низа. Но за да го обходим, просто трябва да циклим докато `string[i] != '\0'`.  
Четенето със std::cin автоматично слага `'\0'` на края на низа!!!  
Щом става дума за низове (масиви от `char`) **винаги ще предпочитаме този начин на четене**.  
Съответно, същият синтаксис работи и за принтиране:  
`std::cout << string;`  
Ето и решението на задачата, използвайки туко що споменатия синтаксис:  
```cpp
int main()
{
    char string[10 + 1];    //+1 for '\0' if the string is exactly 10 chars long
    std::cin >> string;

    int counter = 0;
    for (int i = 0; string[i] != '\0'; i++)
    {
        if (string[i] == '(')
            counter++;
        else if (string[i] == ')')
            counter--;
        else
        {
            std::cout << "Invalid String!";
            return 1;
        }
        if (counter < 0)
        {
            std::cout << "false";
            return 0;
        }
    }

    if (counter == 0)
        std::cout << "true";
    else
        std::cout << "false";
}
```
Идеята на тази задача е да видим дали низ, съставен само от скоби, е валиден. Това значи за всяка отваряща скоба да има затваряща такава в дясно от нея, съответно и обратното за затварящите.  
За тази цел си пазим един брояч колко навътре сме в израза от скоби. За всяка отваряща скоба влизаме +1 навътре, за всяка затваряща -1 навън. Трикът е, че ако в някакъв момент броячът ни стане отрицателен, то имаме повече затварящи скоби отколкото отварящи в този момент и изразът става невалиден.  
Също, след като приключим обхождането, трябва да видим дали не са останали пък повече отварящи скоби. С проверката `counter == 0` подсигуряваме, че изразът е балансиран.

(тази задача определено е по-добре да се направи като отделна функция, която връща bool)